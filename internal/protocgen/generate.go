package protocgen

import (
	"fmt"

	"github.com/pentops/j5/gen/j5/messaging/v1/messaging_j5pb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
)

const Version = "0.0.0"

var (
	o5MessagePkg         = protogen.GoImportPath("github.com/pentops/o5-messaging/gen/o5/messaging/v1/messaging_pb")
	contextPkg           = protogen.GoImportPath("context")
	o5msgPkg             = protogen.GoImportPath("github.com/pentops/o5-messaging/o5msg")
	requestMetadataType  = "j5.messaging.v1.RequestMetadata"
	j5MessagePkg         = protogen.GoImportPath("github.com/pentops/j5/gen/j5/messaging/v1/messaging_j5pb")
	requestMetadataIdent = j5MessagePkg.Ident("RequestMetadata")
)

type KeyValue struct {
	Key  string
	Code []interface{}
}

type Config struct {
	ExtraHeaders []KeyValue
}

func (cfg Config) Generate(gen *protogen.Plugin) error {
	gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

	for _, f := range gen.Files {
		if !f.Generate {
			continue
		}
		if _, err := cfg.generateFile(gen, f); err != nil {
			return err
		}
	}
	return nil
}

// generateFile generates a _messaging.pb.go file containing various mappings Messaging Over gRPC extensions
func (cfg Config) generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	if len(file.Services) == 0 {
		return nil, nil
	}
	filename := file.GeneratedFilenamePrefix + "_o5_messaging.pb.go"

	var g *protogen.GeneratedFile
	for _, service := range file.Services {
		opts, _ := proto.GetExtension(service.Desc.Options(), messaging_j5pb.E_Service).(*messaging_j5pb.ServiceConfig)
		if opts == nil {

			oldAnnotation, _ := proto.GetExtension(service.Desc.Options(), messaging_j5pb.E_Config).(*messaging_j5pb.Config)
			if oldAnnotation == nil {
				continue
			}
			newOpts, err := upscale(oldAnnotation)
			if err != nil {
				return nil, err
			}
			opts = newOpts
		}

		if g == nil {
			g = gen.NewGeneratedFile(filename, file.GoImportPath)
			g.P("// Code generated by protoc-gen-go-o5-messaging. DO NOT EDIT.")
			g.P("// versions:")
			g.P("// - protoc-gen-go-o5-messaging ", Version)
			g.P("// source: ", file.Desc.Path())
			g.P()
			g.P("package ", file.GoPackageName)
			g.P()
		}
		if err := cfg.genServiceExtension(g, service, opts); err != nil {
			return nil, err
		}
	}
	return g, nil
}

func getFieldForType(message *protogen.Message, typeName string) (*protogen.Field, error) {
	var foundField *protogen.Field
	for _, field := range message.Fields {

		msg := field.Desc.Message()
		if msg == nil {
			continue
		}
		if string(msg.FullName()) == typeName {
			if foundField != nil {
				return nil, fmt.Errorf("Multiple %s messages in %s", typeName, message.Desc.FullName())
			}
			foundField = field
		}
	}
	foundField, err := getOptionalFieldForType(message, typeName)
	if err != nil {
		return nil, err
	}
	if foundField == nil {
		return nil, fmt.Errorf("No %s messages in %s", typeName, message.Desc.FullName())
	}
	return foundField, nil
}

func getOptionalFieldForType(message *protogen.Message, typeName string) (*protogen.Field, error) {
	var foundField *protogen.Field
	for _, field := range message.Fields {

		msg := field.Desc.Message()
		if msg == nil {
			continue
		}
		if string(msg.FullName()) == typeName {
			if foundField != nil {
				return nil, fmt.Errorf("Multiple %s messages in %s", typeName, message.Desc.FullName())
			}
			foundField = field
		}
	}
	return foundField, nil
}

func upscale(oldAnnotation *messaging_j5pb.Config) (*messaging_j5pb.ServiceConfig, error) {
	newOpts := &messaging_j5pb.ServiceConfig{}
	switch topicType := oldAnnotation.Type.(type) {
	case *messaging_j5pb.Config_Broadcast:
		newOpts.Role = &messaging_j5pb.ServiceConfig_Publish_{
			Publish: &messaging_j5pb.ServiceConfig_Publish{},
		}
		newOpts.TopicName = &topicType.Broadcast.Name

	case *messaging_j5pb.Config_Unicast:
		newOpts.Role = &messaging_j5pb.ServiceConfig_Publish_{
			Publish: &messaging_j5pb.ServiceConfig_Publish{},
		}
		newOpts.TopicName = &topicType.Unicast.Name

	case *messaging_j5pb.Config_Request:
		newOpts.Role = &messaging_j5pb.ServiceConfig_Request_{
			Request: &messaging_j5pb.ServiceConfig_Request{},
		}
		name := topicType.Request.Name + "_request"
		newOpts.TopicName = &name

	case *messaging_j5pb.Config_Reply:
		newOpts.Role = &messaging_j5pb.ServiceConfig_Reply_{
			Reply: &messaging_j5pb.ServiceConfig_Reply{},
		}
		name := topicType.Reply.Name + "_reply"
		newOpts.TopicName = &name
	default:
		return nil, fmt.Errorf("unknown / unsupported topic type %v", topicType)
	}
	return newOpts, nil

}

type Method struct {
	*protogen.Method
	replyReplyToField   *protogen.Field
	requestReplyToField *protogen.Field
}

func (cfg Config) genServiceExtension(g *protogen.GeneratedFile, service *protogen.Service, opts *messaging_j5pb.ServiceConfig) error {

	g.P("// Service: " + service.GoName)
	parsedMethods := make([]Method, 0, len(service.Methods))

	exposeRequestMetadata := func(message *protogen.Message, requestMetadata *protogen.Field) {
		if requestMetadata == nil {
			return
		}

		g.P("// Expose Request Metadata")
		g.P("func (msg *", message.GoIdent, ") SetJ5RequestMetadata(md *", requestMetadataIdent, ") {")
		g.P("  msg.", requestMetadata.GoName, " = md")
		g.P("}")
		g.P("func (msg *", message.GoIdent, ") GetJ5RequestMetadata()  *", requestMetadataIdent, " {")
		g.P("  return msg.", requestMetadata.GoName)
		g.P("}")
	}

	for _, method := range service.Methods {
		mm := Method{Method: method}

		switch topicType := opts.Role.(type) {
		case *messaging_j5pb.ServiceConfig_Publish_:

		case *messaging_j5pb.ServiceConfig_Request_:
			requestMetadata, err := getFieldForType(method.Input, requestMetadataType)
			if err != nil {
				return err
			}

			mm.requestReplyToField = requestMetadata
			exposeRequestMetadata(method.Input, requestMetadata)

		case *messaging_j5pb.ServiceConfig_Reply_:
			requestMetadata, err := getFieldForType(method.Input, requestMetadataType)
			if err != nil {
				return err
			}

			mm.replyReplyToField = requestMetadata
			exposeRequestMetadata(method.Input, requestMetadata)

		default:
			return fmt.Errorf("unknown / unsupported message role %v", topicType)
		}

		parsedMethods = append(parsedMethods, mm)
	}

	senderName := service.GoName + "TxSender"
	g.P("type ", senderName, "[C any] struct {")
	g.P("  sender ", o5msgPkg.Ident("TxSender"), "[C]")
	g.P("}")
	g.P()
	g.P("func New", senderName, "[C any] (sender ", o5msgPkg.Ident("TxSender"), "[C]) (*", senderName, "[C]) {")
	g.P("  sender.Register(", o5msgPkg.Ident("TopicDescriptor"), "{")
	g.P("    Service: \"", service.Desc.FullName(), "\",")
	g.P("    Methods: []", o5msgPkg.Ident("MethodDescriptor"), "{")
	for _, method := range parsedMethods {
		g.P("      {")
		g.P("        Name: \"", method.Desc.Name(), "\",")
		g.P("        Message: (*", method.Input.GoIdent, ").ProtoReflect(nil).Descriptor(),")
		g.P("      },")
	}
	g.P("    },")

	g.P("  })")
	g.P("  return &", senderName, "[C]{sender: sender}")
	g.P("}")
	g.P()

	collectorName := service.GoName + "Collector"
	g.P("type ", collectorName, "[C any] struct {")
	g.P("  collector ", o5msgPkg.Ident("Collector"), "[C]")
	g.P("}")
	g.P()
	g.P("func New", collectorName, "[C any] (collector ", o5msgPkg.Ident("Collector"), "[C]) (*", collectorName, "[C]) {")
	g.P("  collector.Register(", o5msgPkg.Ident("TopicDescriptor"), "{")
	g.P("    Service: \"", service.Desc.FullName(), "\",")
	g.P("    Methods: []", o5msgPkg.Ident("MethodDescriptor"), "{")
	for _, method := range parsedMethods {
		g.P("      {")
		g.P("        Name: \"", method.Desc.Name(), "\",")
		g.P("        Message: (*", method.Input.GoIdent, ").ProtoReflect(nil).Descriptor(),")
		g.P("      },")
	}
	g.P("    },")

	g.P("  })")
	g.P("  return &", collectorName, "[C]{collector: collector}")
	g.P("}")
	g.P()

	publisherName := service.GoName + "Publisher"
	g.P("type ", publisherName, " struct {")
	g.P("  publisher ", o5msgPkg.Ident("Publisher"))
	g.P("}")
	g.P()
	g.P("func New", publisherName, " (publisher ", o5msgPkg.Ident("Publisher"), ") (*", publisherName, ") {")
	g.P("  publisher.Register(", o5msgPkg.Ident("TopicDescriptor"), "{")
	g.P("    Service: \"", service.Desc.FullName(), "\",")
	g.P("    Methods: []", o5msgPkg.Ident("MethodDescriptor"), "{")
	for _, method := range parsedMethods {
		g.P("      {")
		g.P("        Name: \"", method.Desc.Name(), "\",")
		g.P("        Message: (*", method.Input.GoIdent, ").ProtoReflect(nil).Descriptor(),")
		g.P("      },")
	}
	g.P("    },")

	g.P("  })")
	g.P("  return &", publisherName, "{publisher: publisher}")
	g.P("}")
	g.P()

	for _, method := range parsedMethods {
		g.P("// Method: " + method.GoName)
		g.P("")
		g.P("func (msg *", method.Input.GoIdent, ") O5MessageHeader() ", o5msgPkg.Ident("Header"), " {")
		g.P("  header := ", o5msgPkg.Ident("Header"), "{")
		g.P("    GrpcService: \"", service.Desc.FullName(), "\",")
		g.P("    GrpcMethod: \"", method.Desc.Name(), "\",")
		g.P("    Headers: map[string]string{")
		for _, header := range cfg.ExtraHeaders {
			codeLine := append([]interface{}{`"`, header.Key, `": `}, header.Code...)
			codeLine = append(codeLine, ",")
			g.P(codeLine...)
		}

		g.P("    },")

		if opts.TopicName != nil {
			g.P("  DestinationTopic: \"", *opts.TopicName, "\",")
		}
		g.P("  }")
		if method.replyReplyToField != nil {
			g.P("if msg.Request != nil {")
			g.P("header.Extension = &", o5MessagePkg.Ident("Message_Reply_"), "{")
			g.P("	Reply: &", o5MessagePkg.Ident("Message_Reply"), "{")
			g.P("		ReplyTo: msg.", method.replyReplyToField.GoName, ".ReplyTo,")
			g.P("	},")
			g.P("}")
			g.P("}")
		} else if method.requestReplyToField != nil {
			g.P("if msg.Request != nil {")
			g.P("  header.Extension = &", o5MessagePkg.Ident("Message_Request_"), "{")
			g.P("    Request: &", o5MessagePkg.Ident("Message_Request"), "{")
			g.P("      ReplyTo: msg.", method.requestReplyToField.GoName, ".ReplyTo,")
			g.P("    },")
			g.P("  }")
			g.P("} else {")
			g.P("  header.Extension = &", o5MessagePkg.Ident("Message_Request_"), "{")
			g.P("    Request: &", o5MessagePkg.Ident("Message_Request"), "{")
			g.P("      ReplyTo: \"\",")
			g.P("    },")
			g.P("  }")
			g.P("}")

		}

		g.P("  return header")
		g.P("}")
		g.P()

		g.P("func (send ", senderName, "[C]) ", method.GoName, "(ctx ", contextPkg.Ident("Context"), ", sendContext C, msg *", method.Input.GoIdent, ") error {")
		g.P("  return send.sender.Send(ctx, sendContext, msg)")
		g.P("}")
		g.P()
		g.P("func (collect ", collectorName, "[C]) ", method.GoName, "(sendContext C, msg *", method.Input.GoIdent, ") {")
		g.P("  collect.collector.Collect(sendContext, msg)")
		g.P("}")
		g.P()
		g.P("func (publish ", publisherName, ") ", method.GoName, "(ctx ", contextPkg.Ident("Context"), ", msg *", method.Input.GoIdent, ") error {")
		g.P("  return publish.publisher.Publish(ctx, msg)")
		g.P("}")

		/*
			upsertField, err := getOptionalFieldForType(method.Input, "messaging.v1.UpsertMetadata")
			if err != nil {
				return err
			}
			if upsertField != nil {
				g.P(`if msg.`, upsertField.GoName, ` != nil {`)
				g.P(`headers["o5-upsert-entity-id"] = msg.`, upsertField.GoName, `.EntityId`)
				// cheating with RFC3339 string so we don't have to import time package in the generated code.
				g.P(`headers["o5-upsert-entity-timestamp"] = msg.`, upsertField.GoName, `.Timestamp.AsTime().Format("`, time.RFC3339, `")`)
				g.P(`}`)
			}

			g.P("return headers")
			g.P("}")
			g.P("")
		*/
	}
	return nil
}
